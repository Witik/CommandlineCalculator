\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\bibliographystyle{plain}
\tolerance=1000
\usepackage[normalem]{ulem}
\usepackage{ tipa }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{circuitikz}
\usepackage{enumitem}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{longtable}
\usepackage{ltablex}
\usepackage{marvosym}
\usepackage{microtype}
\usepackage{rotating}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{wasysym}
\usepackage{wrapfig}
\usepackage{xcolor,colortbl}
\usetikzlibrary{tikzmark,decorations.pathmorphing}
\author{Sasja Gillissen, Martin Huijben, Martijn Terpstra}
\date{\today}
\title{Testing Techniques\\
  \textbf{Assignment 4: Active Learning}}
\hypersetup{
 pdfauthor={Sasja Gillissen, Martin Huijben, Martijn Terpstra},
 pdflang={English}}
\begin{document}
\maketitle

In this assignment we learned the models of two systems. First we
modeled a Chocolate bar machine that ran in a web browser. Secondly we
tested a command line implementation of the Bounded Retransmission Protocol.

\section{Chocolate bar machine}
The chocolate bar machine is a javascript web application that modeled
a snack dispenser. We can click buttons to simulate inserting coins
and pressing physical buttons.

We ran our SUT in Firefox and tested it with selenium.

\subsection{Clicking around}
Initially we experimented with the SUT manually using our web browser.

One observation we made is that the maximum amount of money that we
can insert before the system refuses new coins varies between 0,35 and
0,45 cents.

\subsection{Manual counterexamples}
We tested the three learning methods L*, RivestShapire and TTT.

After the first step, RivestShapire and TTT have just one state. L*
has three states. As a counterexample for RivestShapire and TTT we
added '10ct mars' which gives OK instead of NOK. A step later
RivestShapire has 9 states, TTT three states. It is clear that
RivestShapire needs a lot less counterexamples. L* is now 4 states. It
had a good start, but is now slowing down.

When counterexamples are hard to find RivestShapire has a clear
advantage over L* and TTT. However RivestShapire does take a lot of
time to get to those 9 states. This means that if counterexamples are
easy to find, maybe L* and TTT are better.

%% After that we started on automated testing.

\subsection{Learning a full model}
We chose RivestShapire, because it is huge and seems to be finished

The counterexamples we gave are:
\begin{itemize}
	\item 10ct mars
\end{itemize}

The hypotheses can be found in the map basic-learning results in the map with the name of the learning method.

\subsection{Why is this model complete?}
We stated in the beginning that the highest amount of money in the machine is 45ct. This would mean that there are 10 possible states, each where we add 5ct until we have 45ct. But 45ct can not be reached by clicking only 5ct. So there has to be less states. RivestShapire has 9 states, so there can't possibly be more states. Also, from every state it seems that 5ct sends us to one state higher, 10ct sends us to two states higher and buying stuff lowers us.

%% 4. Why do you think you have learned the complete model? Give an
%% argument.

%% 5. Start learning again with TTT. How many times can you provide
%% the last counterexample you used in learning the complete model, as
%% a counterexample in this run?

%% 6. Explain, based on the theory from the lecture, why it is possible that an
%% input trace is accepted multiple times as a counterexample.

\subsection{Giving TTT our last counterexample}
Our last counterexample is 10ct mars. We can provide it only once. It does not give the right model.
We also tried giving something larger: snickers 5ct 10ct snickers 5ct 10ct 5ct 10ct twix snickers.
Still, TTT accepts this only once. It generates 9 states, giving it a high probability of being a complete model.

\subsection{giving a counterexample multiple times}
We have no idea. We did not find a counterexample that TTT accepts more than once.

We think RandomWalk is the best testing method. This is because the
other testing methods did not finish within a reasonable time.

\section{Bounded Retransmission Protocol}

The Bounded Retransmission Protocol is a command line implementation
of protocol for transmitting data over infrared. We could simulate
action by sending strings to web socket that the program listens on.

%% \subsection{Model learning}
We tested the different implementations and compared them to the
reference implementation.

During our testing we noticed that TTT found counterexamples that L* and
RiverShapire did not find.

We found that mutants 1,2,4 and 6 were incorrect implementations.
However RiverShapire and L* did not find a counterexample for mutant 2
while TTT did find an example.

\begin{center}
\begin{tabular}{l|l}
\textbf{Mutant} & \textbf{Counterexample}\\
\hline
1 & IREQ\_0\_0\_0 $\Rightarrow$ ITIMEOUT\\
2 & IREQ\_0\_0\_1 $\Rightarrow$ ITIMEOUT $\Rightarrow$ ITIMEOUT $\Rightarrow$ IACK $\Rightarrow$ IACK\\
4 & IREQ\_0\_0\_0 $\Rightarrow$ IACK $\Rightarrow$ IACK\\
6 & IREQ\_0\_0\_1 $\Rightarrow$ IACK $\Rightarrow$ IACK\\
\end{tabular}
\end{center}

The remaining implementations, mutant 3 and mutant 5, did not have
counterexamples so they are equal to the reference implementation.

%% \subsection{Finding out which implementation is equal to which reference implementation}
%% find out which of the implementations of the manufacturers is equal
%% to the reference implementation

%% \subsection{Differences (with counterexamples) between manufacturers}
%% For each of the implementations of the manufacturers, write down whether
%% they were equal, and if not, provide the counterexample.

\end{document}

%%  LocalWords: tikzmark decorations pathmorphing pdfauthor pdflang
%%  LocalWords: Retransmission SUT RiverShapire TTT RandomWalk
%%  LocalWords: WMethod WpMethod mutant2 RivestShapire
