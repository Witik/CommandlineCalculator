\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\bibliographystyle{plain}
\tolerance=1000
\usepackage[normalem]{ulem}
\usepackage{ tipa }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{circuitikz}
\usepackage{enumitem}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{longtable}
\usepackage{ltablex}
\usepackage{marvosym}
\usepackage{microtype}
\usepackage{rotating}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{wasysym}
\usepackage{wrapfig}
\usepackage{xcolor,colortbl}
\usetikzlibrary{tikzmark,decorations.pathmorphing}
\author{Sasja Gillissen, Martin Huijben, Martijn Terpstra}
\date{\today}
\title{Testing Techniques\\
  \textbf{Assignment 4: Active Learning}}
\hypersetup{
 pdfauthor={Sasja Gillissen, Martin Huijben, Martijn Terpstra},
 pdflang={English}}
\begin{document}
\maketitle

In this assignment we learned the models of two systems. First we
modeled a Chocolate bar machine that ran in a web browser. Secondly we
tested a command line implementation of the Bounded Retransmission Protocol.

\section{Chocolate bar machine}
The chocolate bar machine is a javascript web application that modeled
a snack dispenser. We can click buttons to simulate inserting coins
and pressing physical buttons.

We ran our SUT in Firefox and tested it with selenium.

\subsection{Clicking around}
Initially we experimented with the SUT manually using our web browser.

One observation we made is that the maximum amount of money that we
can insert before the system refuses new coins varies between 0,35 and
0,45 cents.

\subsection{Manual counterexamples}
We tested the three learning methods L*, RivestShapire and TTT.

After the first step, RivestShapire and TTT have just one state. L*
has three states. As a counterexample for RivestShapire and TTT we
added '10ct mars' which gives OK instead of NOK. A step later
RivestShapire has 9 states, TTT three states. It is clear that
RivestShapire needs a lot less counterexamples. L* is now 4 states. It
had a good start, but is now slowing down.

When counterexamples are hard to find RivestShapire has a clear
advantage over L* and TTT. However RivestShapire does take a lot of
time to get to those 9 states. This means that if counterexamples are
easy to find, maybe L* and TTT are better, but this has to be tested.

%% After that we started on automated testing.

\subsection{counterexamples}
%% 3. Choose one learning method to learn the complete model. Give all the
%% counterexamples that you used. Also include all the hypotheses.

\subsection{Why this model is correct}
%% 4. Why do you think you have learned the complete model? Give an
%% argument.

%% 5. Start learning again with TTT. How many times can you provide
%% the last counterexample you used in learning the complete model, as
%% a counterexample in this run?

%% 6. Explain, based on the theory from the lecture, why it is possible that an
%% input trace is accepted multiple times as a counterexample.

\subsection{Results of automatic learning}
%% 1. Choose some learning method (and write this down).

%% 2. Learn a model automatically with the testing methods RandomWalk,
%% Learn a model of them reference implementations (jars)
%%, answer
%% the following questions:
%% (a) After how much time does the learner stop?
%% (b) Is the found model the same model as you learned by supplying
%% counterexamples yourself? Why (not)?

%% 3. Explain which testing method worked the best according to you.

\section{Bounded Retransmission Protocol}

%% \subsection{Model learning}
We tested the reference implementations.

During our testing we noticed that TTT found counterexamples that L* and
RiverShapire did not find.

We found that mutants 1,2,4 and 6 were incorrect implementations.
However RiverShapire and L* did not find a counterexample for mutant 2
while TTT did find an example.

\begin{center}
\begin{tabular}{l|l}
\textbf{Mutant} & \textbf{Counterexample}\\
\hline
1 & IREQ\_0\_0\_0 $\Rightarrow$ ITIMEOUT\\
2 & IREQ\_0\_0\_1 $\Rightarrow$ ITIMEOUT $\Rightarrow$ ITIMEOUT $\Rightarrow$ IACK $\Rightarrow$ IACK\\
4 & IREQ\_0\_0\_0 $\Rightarrow$ IACK $\Rightarrow$ IACK\\
6 & IREQ\_0\_0\_1 $\Rightarrow$ IACK $\Rightarrow$ IACK\\
\end{tabular}
\end{center}

The remaining implementations, mutant 3 and mutant 5, did not have
counterexamples so they are equal to the reference implementation.

%% \subsection{Finding out which implementation is equal to which reference implementation}
%% find out which of the implementations of the manufacturers is equal
%% to the reference implementation

%% \subsection{Differences (with counterexamples) between manufacturers}
%% For each of the implementations of the manufacturers, write down whether
%% they were equal, and if not, provide the counterexample.

\end{document}

%%  LocalWords: tikzmark decorations pathmorphing pdfauthor pdflang
%%  LocalWords: Retransmission SUT RiverShapire TTT RandomWalk
%%  LocalWords: WMethod WpMethod mutant2 RivestShapire
