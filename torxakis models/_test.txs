-- TODO: ons model geeft nog geen result terug


CHANDEF  Chans ::=  Action  :: CalcAction
                    ; Result :: CalcResult
ENDDEF

MODELDEF Model ::=
    CHAN IN    Action
    CHAN OUT   Result

    BEHAVIOUR
            CalculatorLoop [ Action, Result] ( )

ENDDEF


PROCDEF  CalculatorLoop  [ Act :: CalcAction; Res :: CalcResult] ( )
    ::=
            Act ? opn [[ isExpression(opn)  ]] >-> Res ! IntResult(operationToInt(exp(opn))) >-> CalculatorLoop [ Act, Res] ( )
        ##
            Act ? opn [[ isExit(opn) ]] >-> Res ! StringResult("Bye!")
        ##
            Act ? opn [[ isFuncDef(opn) ]] >-> Act ! StringAction(getFuncApplication(funI(opn))) >-> Res ! IntResult(funcResult(funI(opn))) >-> CalculatorLoop [Act, Res] ( )
        ##
            Act ? opn [[ isVarDef(opn) ]] >-> Act ! StringAction(getVarApplication(funI(opn))) >-> Res ! IntResult(varResult(funI(opn))) >-> CalculatorLoop [Act, Res] ( )
ENDDEF



CNECTDEF  Sut
    ::=
        CLIENTSOCK

-- verwacht input
        CHAN  OUT  Action            HOST "localhost"  PORT 7890
        ENCODE     Action ? opn      ->  ! calcActionToString(opn)

-- echo'd iets terug
        CHAN  IN   Result            HOST "localhost"  PORT 7890
        DECODE     Result ! calcResultFromString(s)     <-   ? s
ENDDEF

--
TYPEDEF  Operation
    ::=
          Plus  { p1, p2 :: Operation }
        | Minus { m1, m2 :: Operation }
        | Times { t1, t2 :: Operation }
		--| Divide { p1, p2 :: Operation }
		| Integer { i :: Int }
ENDDEF

TYPEDEF CalcAction
    ::=
            Expression { exp :: Operation }
        |   FuncDef { funI :: Int }
        |   VarDef  { varI :: Int }
        |   StringAction { str :: String }
        |   Exit 
ENDDEF

TYPEDEF CalcResult
    ::=
            IntResult { i :: Int }
        |   StringResult { str :: String }
ENDDEF

FUNCDEF calcResultFromString(result :: String) :: CalcResult ::=
    IF (isNumerical(result)) THEN
        IntResult(fromString(result))
    ELSE 
        StringResult(result)
    FI
ENDDEF

FUNCDEF isNumerical(numString :: String) :: Bool ::=
    strinre(numString, REGEX('[0-9]*'))
ENDDEF

FUNCDEF calcActionToString(act :: CalcAction) :: String ::=
    IF isExpression(act) THEN
        operationToString(exp(act))
    ELSE IF isFuncDef(act) THEN
        getFuncDef(funI(act))
    ELSE IF isVarDef(act) THEN
        getVarDef(varI(act))
    ELSE
        "exit()"
    FI FI FI
ENDDEF

FUNCDEF getFuncDef(id :: Int) :: String ::=
    IF id == 0 THEN
        "id(x) := x"
    ELSE IF id == 1 THEN
        "f(x) := x*2"
    ELSE IF id == 2 THEN
        "g(x,y) := x+y"
    ELSE
        getFuncDef(id-3)
    FI FI FI
ENDDEF

FUNCDEF getVarDef(id :: Int) :: String ::=
    IF id == 0 THEN
        "varx = 0"
    ELSE IF id == 1 THEN
        "vary = 5*2"
    ELSE IF id == 2 THEN
        "varz = 521+231"
    ELSE
        getVarDef(id-3)
    FI FI FI
ENDDEF

FUNCDEF getFuncApplication(id :: Int) :: String ::=
    IF id == 0 THEN
        "id(5)"
    ELSE IF id == 1 THEN
        "f(3)"
    ELSE IF id == 2 THEN
        "g(7,3)"
    ELSE
        getFuncApplication(id-3)
    FI FI FI
ENDDEF

FUNCDEF getVarApplication(id :: Int) :: String ::=
    IF id == 0 THEN
        "5+varx"
    ELSE IF id == 1 THEN
        "vary-1"
    ELSE IF id == 2 THEN
        "varz/10"
    ELSE
        getVarApplication(id-3)
    FI FI FI
ENDDEF


FUNCDEF funcResult(id :: Int) :: Int ::=
    IF id == 0 THEN
        5
    ELSE IF id == 1 THEN
        9
    ELSE IF id == 2 THEN
        10
    ELSE
        funcResult(id-3)
    FI FI FI
ENDDEF

FUNCDEF varResult(id :: Int) :: Int ::=
    IF id == 0 THEN
        5
    ELSE IF id == 1 THEN
        9
    ELSE IF id == 2 THEN
        10
    ELSE
        varResult(id-3)
    FI FI FI
ENDDEF

FUNCDEF operationToString(op::Operation) :: String ::=
	IF isPlus(op) THEN
            "(" ++ operationToString(p1(op)) ++ " + " ++ operationToString(p2(op)) ++ ")"
	ELSE IF isMinus(op) THEN
            "(" ++ operationToString(m1(op)) ++ " - " ++ operationToString(m2(op)) ++ ")"
	ELSE IF isTimes(op) THEN
            "(" ++ operationToString(t1(op)) ++ " * " ++ operationToString(t2(op)) ++ ")"
	ELSE IF isInteger(op) THEN
            toString(i(op))
	ELSE
            ""
    FI FI FI FI
ENDDEF

--


FUNCDEF operationToInt(op::Operation) :: Int ::=
    IF isPlus(op) THEN
        operationToInt(p1(op)) + operationToInt(p2(op))
    ELSE IF isMinus(op) THEN
        operationToInt(m1(op))  - operationToInt(m2(op))
    ELSE IF isTimes(op) THEN
        operationToInt(t1(op)) * operationToInt(t2(op))
    ELSE IF isInteger(op) THEN
        i(op)
    ELSE
        0
    FI FI FI FI
ENDDEF
